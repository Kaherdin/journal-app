This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-07-01T08:57:14.326Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.eslintrc.json
.gitignore
app/add-entry/page.tsx
app/api/add-entry/route.ts
app/api/ask/route.ts
app/api/convert/route.ts
app/api/delete-entry/route.ts
app/api/generate-entry/route.ts
app/api/get-last-entries/route.ts
app/api/import-entries/route.ts
app/api/regenerate-embeddings/route.ts
app/api/transcribe/route.ts
app/ask/page.tsx
app/entries/page.tsx
app/generate-entry/page.tsx
app/globals.css
app/import/page.tsx
app/layout.tsx
app/lib/openai.ts
app/lib/supabase.ts
app/page.tsx
app/types/index.ts
bluerint-fixed.json
components.json
components/navigation.tsx
components/TextWithAudio.tsx
components/ui/alert-dialog.tsx
components/ui/button.tsx
components/ui/card.tsx
components/ui/form.tsx
components/ui/input.tsx
components/ui/label.tsx
components/ui/textarea.tsx
DOC_JOURNAL.md
eslint.config.mjs
lib/utils.ts
migrate-gratitude-jsonb.sql
next.config.js
next.config.ts
package.json
postcss.config.mjs
public/file.svg
public/globe.svg
public/next.svg
public/vercel.svg
public/window.svg
README.md
split-journal.js
supabase-pgvector.sql
supabase/migrations/journal_schema.sql
tsconfig.json

================================================================
Repository Files
================================================================

================
File: .eslintrc.json
================
{
  "extends": [
    "next/core-web-vitals"
  ],
  "rules": {
    "@typescript-eslint/no-unused-vars": "off"
  }
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
/data_journal

================
File: app/add-entry/page.tsx
================
'use client';

import { useState } from 'react';
import { Navigation } from '@/components/navigation';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { useRouter } from 'next/navigation';

export default function AddEntry() {
  const router = useRouter();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState(false);
  
  const [formData, setFormData] = useState({
    date: new Date().toISOString().split('T')[0],
    mit: '',
    content: '',
    prompt: '',
    gratitude: '',
    productivite: 5,
    sport: 5,
    energie: 5,
    proprete: 5,
    art: 5
  });

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const handleRangeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: parseInt(value) }));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    setError('');
    setSuccess(false);

    try {
      // Format the data according to the API expectations
      const apiData = {
        date: formData.date,
        mit: formData.mit,
        content: formData.content,
        prompt: formData.prompt || undefined,
        gratitude: formData.gratitude ? formData.gratitude.split(',').map(item => item.trim()) : undefined,
        notes: {
          productivite: formData.productivite,
          sport: formData.sport,
          energie: formData.energie,
          proprete: formData.proprete,
          art: formData.art
        }
      };

      const response = await fetch('/api/add-entry', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(apiData),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Une erreur est survenue');
      }

      setSuccess(true);
      
      // Reset form
      setFormData({
        date: new Date().toISOString().split('T')[0],
        mit: '',
        content: '',
        prompt: '',
        gratitude: '',
        productivite: 5,
        sport: 5,
        energie: 5,
        proprete: 5,
        art: 5
      });
      
      // Redirect after successful submission
      setTimeout(() => {
        router.push('/entries');
      }, 2000);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Une erreur est survenue');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <main className="flex min-h-screen flex-col items-center p-8">
      <div className="max-w-4xl w-full">
        <h1 className="text-4xl font-bold mb-8 text-center">Ajouter une entrée</h1>
        
        <Navigation />
        
        <Card>
          <CardHeader>
            <CardTitle>Nouvelle entrée de journal</CardTitle>
          </CardHeader>
          <CardContent>
            {error && (
              <div className="mb-4 p-4 bg-red-100 text-red-700 rounded-md">
                {error}
              </div>
            )}
            
            {success && (
              <div className="mb-4 p-4 bg-green-100 text-green-700 rounded-md">
                Entrée ajoutée avec succès! Redirection...
              </div>
            )}
            
            <form onSubmit={handleSubmit} className="space-y-6">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="space-y-2">
                  <label htmlFor="date" className="text-sm font-medium">
                    Date
                  </label>
                  <Input
                    id="date"
                    name="date"
                    type="date"
                    value={formData.date}
                    onChange={handleChange}
                    required
                  />
                </div>
                
                <div className="space-y-2">
                  <label htmlFor="mit" className="text-sm font-medium">
                    Tâche la plus importante (MIT)
                  </label>
                  <Input
                    id="mit"
                    name="mit"
                    value={formData.mit}
                    onChange={handleChange}
                    placeholder="Qu'est-ce qui est le plus important aujourd'hui?"
                    required
                  />
                </div>
              </div>
              
              <div className="space-y-2">
                <label htmlFor="prompt" className="text-sm font-medium">
                  Prompt (optionnel)
                </label>
                <Input
                  id="prompt"
                  name="prompt"
                  value={formData.prompt}
                  onChange={handleChange}
                  placeholder="Prompt utilisé pour générer cette entrée"
                />
              </div>
              
              <div className="space-y-2">
                <label htmlFor="content" className="text-sm font-medium">
                  Contenu
                </label>
                <Textarea
                  id="content"
                  name="content"
                  value={formData.content}
                  onChange={handleChange}
                  placeholder="Écrivez vos pensées et réflexions ici..."
                  rows={8}
                  required
                />
              </div>
              
              <div className="space-y-2">
                <label htmlFor="gratitude" className="text-sm font-medium">
                  Gratitude (optionnel, séparées par des virgules)
                </label>
                <Input
                  id="gratitude"
                  name="gratitude"
                  value={formData.gratitude}
                  onChange={handleChange}
                  placeholder="le soleil, mon chat, le café"
                />
              </div>
              
              <div className="space-y-4">
                <h3 className="text-lg font-medium">Notes (1-10)</h3>
                
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  <div className="space-y-2">
                    <div className="flex justify-between">
                      <label htmlFor="productivite" className="text-sm">Productivité</label>
                      <span>{formData.productivite}/10</span>
                    </div>
                    <Input
                      id="productivite"
                      name="productivite"
                      type="range"
                      min="1"
                      max="10"
                      value={formData.productivite}
                      onChange={handleRangeChange}
                    />
                  </div>
                  
                  <div className="space-y-2">
                    <div className="flex justify-between">
                      <label htmlFor="sport" className="text-sm">Sport</label>
                      <span>{formData.sport}/10</span>
                    </div>
                    <Input
                      id="sport"
                      name="sport"
                      type="range"
                      min="1"
                      max="10"
                      value={formData.sport}
                      onChange={handleRangeChange}
                    />
                  </div>
                  
                  <div className="space-y-2">
                    <div className="flex justify-between">
                      <label htmlFor="energie" className="text-sm">Énergie</label>
                      <span>{formData.energie}/10</span>
                    </div>
                    <Input
                      id="energie"
                      name="energie"
                      type="range"
                      min="1"
                      max="10"
                      value={formData.energie}
                      onChange={handleRangeChange}
                    />
                  </div>
                  
                  <div className="space-y-2">
                    <div className="flex justify-between">
                      <label htmlFor="proprete" className="text-sm">Propreté</label>
                      <span>{formData.proprete}/10</span>
                    </div>
                    <Input
                      id="proprete"
                      name="proprete"
                      type="range"
                      min="1"
                      max="10"
                      value={formData.proprete}
                      onChange={handleRangeChange}
                    />
                  </div>
                  
                  <div className="space-y-2">
                    <div className="flex justify-between">
                      <label htmlFor="art" className="text-sm">Art</label>
                      <span>{formData.art}/10</span>
                    </div>
                    <Input
                      id="art"
                      name="art"
                      type="range"
                      min="1"
                      max="10"
                      value={formData.art}
                      onChange={handleRangeChange}
                    />
                  </div>
                </div>
              </div>
              
              <Button 
                type="submit" 
                disabled={isSubmitting} 
                className="w-full"
              >
                {isSubmitting ? 'Enregistrement...' : 'Sauvegarder l\'entrée'}
              </Button>
            </form>
          </CardContent>
        </Card>
      </div>
    </main>
  );
}

================
File: app/api/add-entry/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import supabase from '@/app/lib/supabase';
import { createEmbedding } from '@/app/lib/openai';
import { JournalEntry } from '@/app/types';

export async function POST(request: NextRequest) {
  try {
    // Parse request body
    const entry: JournalEntry = await request.json();
    
    // Validate required fields
    if (!entry.date || !entry.mit || !entry.content) {
      return NextResponse.json(
        { error: 'Missing required fields: date, mit, or content' },
        { status: 400 }
      );
    }
    
    // Create embedding from the combined text
    let textToEmbed = `${entry.mit} ${entry.content} ${entry.prompt || ''}`;
    
    // Traiter le champ gratitude selon son format
    if (entry.gratitude) {
      if (Array.isArray(entry.gratitude)) {
        textToEmbed += ' ' + entry.gratitude.join(' ');
      } else if (typeof entry.gratitude === 'object') {
        try {
          const gratitudeValues = Object.values(entry.gratitude);
          textToEmbed += ' ' + gratitudeValues.join(' ');
        } catch (e) {
          console.warn(`Erreur lors du traitement de gratitude:`, e);
        }
      } else if (typeof entry.gratitude === 'string') {
        textToEmbed += ' ' + entry.gratitude;
      }
    }
    
    const embedding = await createEmbedding(textToEmbed);
    
    // Insert into Supabase
    const { data, error } = await supabase
      .from('journal_entries')
      .insert({
        date: entry.date,
        mit: entry.mit,
        content: entry.content,
        prompt: entry.prompt,
        gratitude: entry.gratitude,
        notes: entry.notes,
        embedding,
      })
      .select()
      .single();
    
    if (error) {
      console.error('Error inserting entry:', error);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    
    return NextResponse.json({ success: true, data }, { status: 201 });
  } catch (error) {
    console.error('Error adding journal entry:', error);
    return NextResponse.json(
      { error: 'Failed to add journal entry' },
      { status: 500 }
    );
  }
}

================
File: app/api/ask/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import supabase from '@/app/lib/supabase';
import { createEmbedding, generateCompletion } from '@/app/lib/openai';
import { AskQuestion, JournalEntry } from '@/app/types';

export async function POST(request: NextRequest) {
  try {
    // Parse request body
    const { question }: AskQuestion = await request.json();
    
    if (!question) {
      return NextResponse.json(
        { error: 'Question is required' },
        { status: 400 }
      );
    }
    
    console.log('Question reçue:', question);
    
    // Étape 1: Détection d'année dans la question pour filtrage supplémentaire
    const yearMatch = question.match(/\b(20\d{2})\b/);
    const yearFilter = yearMatch ? yearMatch[1] : null;
    
    // Étape 2: Générer un embedding pour la question
    const embedding = await createEmbedding(question);
    
    // Étape 3: Recherche vectorielle pour trouver les entrées sémantiquement pertinentes
    const { data: vectorEntries, error: vectorError } = await supabase.rpc(
      'match_entries',
      {
        query_embedding: embedding,
        match_threshold: 0.3,
        match_count: 1000 // Augmenté pour avoir un échantillon complet de la base
      }
    );
    
    if (vectorError) {
      console.error('Erreur lors de la recherche vectorielle:', vectorError);
      
      // Fallback: récupérer les entrées en fonction du filtre d'année si présent
      let query = supabase
        .from('journal_entries')
        .select('*');
      
      // Appliquer le filtre d'année si présent
      if (yearFilter) {
        query = query
          .gte('date', `${yearFilter}-01-01`)
          .lte('date', `${yearFilter}-12-31`);
      }
      
      const { data: fallbackEntries, error: fallbackError } = await query
        .order('date', { ascending: false })
        .limit(500); // Augmenté à 500 pour avoir un échantillon bien plus large
      
      if (fallbackError) {
        return NextResponse.json({ 
          error: 'Erreur lors de la récupération des entrées', 
          details: fallbackError 
        }, { status: 500 });
      }
      
      console.log(`Utilisation du fallback: ${fallbackEntries?.length || 0} entrées récupérées${yearFilter ? ` pour ${yearFilter}` : ''}`);
      
      // Continuer avec ces entrées
      return await processEntriesAndGenerateResponse(question, fallbackEntries || [], yearFilter);
    }
    
    console.log(`Recherche vectorielle réussie: ${vectorEntries?.length || 0} entrées trouvées`);
    
    // Filtrer par année si mentionnée dans la question
    let relevantEntries = vectorEntries || [];
    if (yearFilter && relevantEntries.length > 0) {
      const yearStart = new Date(`${yearFilter}-01-01`).toISOString().split('T')[0];
      const yearEnd = new Date(`${yearFilter}-12-31`).toISOString().split('T')[0];
      relevantEntries = relevantEntries.filter(entry => 
        entry.date >= yearStart && entry.date <= yearEnd
      );
      console.log(`Après filtrage par année ${yearFilter}: ${relevantEntries.length} entrées`);
    }
    
    // Si aucune entrée pertinente n'est trouvée, récupérer toutes les entrées
    if (relevantEntries.length === 0) {
      let query = supabase
        .from('journal_entries')
        .select('*');
      
      // Appliquer le filtre d'année si présent
      if (yearFilter) {
        query = query
          .gte('date', `${yearFilter}-01-01`)
          .lte('date', `${yearFilter}-12-31`);
      }
      
      const { data: allEntries, error: allError } = await query
        .order('date', { ascending: false })
        .limit(100);
      
      if (allError) {
        return NextResponse.json({ 
          error: 'Erreur lors de la récupération des entrées', 
          details: allError 
        }, { status: 500 });
      }
      
      console.log(`Aucune entrée vectorielle pertinente, utilisation de ${allEntries?.length || 0} entrées générales${yearFilter ? ` pour ${yearFilter}` : ''}`);
      
      // Continuer avec toutes les entrées
      return await processEntriesAndGenerateResponse(question, allEntries || [], yearFilter);
    }
    
    // Continuer avec les entrées trouvées par la recherche vectorielle
    return await processEntriesAndGenerateResponse(question, relevantEntries, yearFilter);
    
  } catch (error) {
    console.error('Erreur:', error);
    return NextResponse.json(
      { error: 'Une erreur est survenue lors du traitement de votre question', details: error instanceof Error ? error.message : String(error) },
      { status: 500 }
    );
  }
}

// Fonction utilitaire pour traiter les entrées et générer une réponse
async function processEntriesAndGenerateResponse(question: string, entries: JournalEntry[], yearFilter: string | null) {
  try {
    // Compter les entrées par année pour le contexte
    const entriesByYear: Record<string, number> = {};
    entries.forEach(entry => {
      const year = new Date(entry.date).getFullYear().toString();
      entriesByYear[year] = (entriesByYear[year] || 0) + 1;
    });
    
    const yearStats = Object.entries(entriesByYear)
      .map(([year, count]) => `${year}: ${count} entrées`)
      .join(', ');
    
    // Limiter intelligemment le nombre d'entrées en fonction de leur taille
    // On estime approximativement qu'une entrée moyenne = ~500 tokens
    const MAX_TOKENS = 100000; // Légèrement en dessous de la limite de 128k pour garder une marge
    const ESTIMATED_TOKENS_PER_ENTRY = 500;
    const MAX_ENTRIES = Math.floor(MAX_TOKENS / ESTIMATED_TOKENS_PER_ENTRY);
    
    let entriesToUse = entries;
    
    // Si nous avons trop d'entrées, nous devons échantillonner
    if (entries.length > MAX_ENTRIES) {
      console.log(`Trop d'entrées (${entries.length}) pour le contexte, échantillonnage à ${MAX_ENTRIES}`);
      
      // Stratégie d'échantillonnage:
      // 1. Garder les entrées les plus pertinentes (avec la plus grande similitude si disponible)
      // 2. Assurer une bonne distribution sur les différentes périodes
      
      if (entries[0].similarity !== undefined) {
        // Si nous avons des scores de similarité, prioriser les entrées les plus pertinentes
        entriesToUse = [...entries].sort((a, b) => (b.similarity || 0) - (a.similarity || 0)).slice(0, MAX_ENTRIES);
      } else {
        // Sinon, échantillonner de manière uniforme
        const step = Math.ceil(entries.length / MAX_ENTRIES);
        entriesToUse = [];
        for (let i = 0; i < entries.length; i += step) {
          entriesToUse.push(entries[i]);
        }
        // Garantir que nous ne dépassons pas MAX_ENTRIES
        entriesToUse = entriesToUse.slice(0, MAX_ENTRIES);
      }
      
      console.log(`Échantillonnage terminé : ${entriesToUse.length} entrées sélectionnées`);
    }
    
    // Préparer le contexte pour OpenAI avec le sous-ensemble limité
    const contextEntries = entriesToUse.map((entry: JournalEntry) => {
      const formattedDate = new Date(entry.date).toLocaleDateString('fr-FR', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
      
      // Tronquer le contenu si nécessaire pour les entrées très longues
      const maxContentLength = 1000; // Environ 250 tokens
      let content = entry.content || '';
      if (content.length > maxContentLength) {
        content = content.substring(0, maxContentLength) + '... [contenu tronqué]';
      }
      
      // Traiter le champ gratitude qui peut désormais être en format jsonb
      let gratitudeText = '';
      if (entry.gratitude) {
        try {
          // Gérer les différents formats possibles de gratitude
          if (Array.isArray(entry.gratitude)) {
            // Format ancien (tableau de chaînes)
            gratitudeText = `Choses pour lesquelles je suis reconnaissant: ${entry.gratitude.join(', ')}`;
          } else if (typeof entry.gratitude === 'object') {
            // Format nouveau (jsonb)
            const gratitudeEntries = Object.entries(entry.gratitude);
            if (gratitudeEntries.length > 0) {
              gratitudeText = 'Choses pour lesquelles je suis reconnaissant: ';
              gratitudeText += gratitudeEntries
                .map(([key, value]) => {
                  // Si la clé est un nombre, c'est probablement un tableau JSON
                  if (!isNaN(Number(key))) {
                    return value;
                  } else {
                    return `${key}: ${value}`;
                  }
                })
                .join(', ');
            }
          } else if (typeof entry.gratitude === 'string') {
            // Cas où c'est une chaîne simple
            gratitudeText = `Choses pour lesquelles je suis reconnaissant: ${entry.gratitude}`;
          }
        } catch (e) {
          console.warn(`Erreur lors du traitement de gratitude pour l'entrée du ${entry.date}:`, e);
        }
      }
      
      let notesText = '';
      if (entry.notes) {
        try {
          const notesObj = typeof entry.notes === 'string' ? JSON.parse(entry.notes) : entry.notes;
          notesText = Object.entries(notesObj)
            .map(([key, value]) => `${key}: ${value}/10`)
            .join(', ');
        } catch (e) {
          console.warn(`Erreur lors du parsing des notes pour l'entrée du ${entry.date}:`, e);
        }
      }
      
      return `
DATE: ${formattedDate}
TÂCHE PRINCIPALE: ${entry.mit || 'Non spécifiée'}
CONTENU: ${content}
${gratitudeText ? `GRATITUDE: ${gratitudeText}` : ''}
${notesText ? `NOTES: ${notesText}` : ''}
${entry.similarity ? `PERTINENCE: ${(entry.similarity * 100).toFixed(2)}%` : ''}
---
      `.trim();
    }).join('\n\n');
    
    // Déterminer si nous avons une question spécifique à une année
    const yearContext = yearFilter 
      ? `Tu remarqueras que la question concerne spécifiquement l'année ${yearFilter}.` 
      : '';
    
    // Construire le prompt pour OpenAI
    const prompt = `
Tu es un assistant d'analyse de journal personnel. Tu analyses mes entrées de journal pour répondre à mes questions de manière précise.

Question: ${question}

Informations sur mon journal:
- Total des entrées dans ma base: ${entries.length}
- Entrées analysées pour cette question: ${entriesToUse.length}${entriesToUse.length < entries.length ? ` (échantillon des plus pertinentes)` : ''}
- Répartition par année: ${yearStats}
${yearContext}

Voici mes entrées de journal les plus pertinentes par rapport à ma question:

${contextEntries}

Instructions pour ta réponse:
1. Réponds uniquement en te basant sur les informations présentes dans ces entrées de journal.
2. Si les entrées ne contiennent pas suffisamment d'informations pour répondre à ma question, dis-le clairement.
3. Présente les informations de manière organisée et claire, avec des exemples spécifiques tirés des entrées.
4. Si ma question porte sur des statistiques ou tendances (comme "quel mois j'ai été le plus productif"), calcule et présente ces statistiques.
5. Cite les dates spécifiques des entrées pour appuyer tes observations.
    `.trim();
    
    // Générer la réponse avec OpenAI
    const response = await generateCompletion(prompt);
    
    // Retourner la réponse et les entrées utilisées
    return NextResponse.json({
      answer: response,
      entriesCount: entries.length,
      entriesAnalyzed: entriesToUse.length,
      yearStats: entriesByYear,
      entries: entriesToUse.slice(0, 10).map(entry => ({
        id: entry.id,
        date: entry.date,
        mit: entry.mit,
        similarity: entry.similarity || null
      }))
    });
  } catch (error) {
    console.error('Erreur lors du traitement des entrées:', error);
    return NextResponse.json(
      { error: 'Une erreur est survenue lors de la génération de la réponse', details: error instanceof Error ? error.message : String(error) },
      { status: 500 }
    );
  }
}

================
File: app/api/convert/route.ts
================
import { Client } from "@notionhq/client";
import { NotionConverter } from "notion-to-md";
import { DefaultExporter } from "notion-to-md/plugins/exporter";
import { NextResponse } from "next/server";

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const pageId = searchParams.get("pageId");
  const raw = searchParams.get("raw") === "true"; // Check if raw parameter is set to true
  const docFormat = searchParams.get("docFormat") === "true"; // Check if docFormat parameter is set to true

  if (!pageId) {
    return NextResponse.json(
      { error: "Missing pageId parameter" },
      { status: 400 }
    );
  }

  try {
    // Initialize the Notion client
    const notion = new Client({
      auth: process.env.NOTION_KEY,
    });

    // Create a buffer to store the markdown
    const buffer: Record<string, string> = {};

    // Create the exporter to store the result in the buffer
    const exporter = new DefaultExporter({
      outputType: "buffer",
      buffer: buffer,
    });

    // Create the NotionConverter instance with the exporter
    const n2m = new NotionConverter(notion).withExporter(exporter);

    // Convert the Notion page to markdown
    await n2m.convert(pageId);

    // Get the raw markdown content
    let markdown = buffer[pageId] || "";

    // Add vertical spacing between sections (moderate spacing)
    markdown = markdown.replace(/\n(#+\s)/g, "\n\n$1");
    markdown = markdown.replace(/\n(>\s)/g, "\n\n$1");

    // Remove any existing database headers first
    markdown = markdown.replace(/> ⭐ \*\*Mes notes\*\*[\s\n>-]*\n\n/g, "");
    markdown = markdown.replace(/⭐ Mes notes\n⭐ Mes notes/g, "Mes notes");

    // Ensure consistent formatting for Mes notes section
    markdown = markdown.replace(/⭐ Mes notes/g, "**Mes notes**:");

    // Check for database references in the format [0](database_id)
    const databaseRegex = /\[0\]\(([a-f0-9-]+)\)/g;
    const databaseMatches = [...markdown.matchAll(databaseRegex)];

    // Process each database reference found
    for (const match of databaseMatches) {
      const databaseId = match[1];
      try {
        // Removed database schema fetch since we're using a simpler approach

        // Query the database to get rows
        const response = await notion.databases.query({
          database_id: databaseId,
          page_size: 100, // Limit results
        });

        // Use a simplified list format instead of a table
        let tableMarkdown = `**Mes notes**:\n`;

        // Collect the data with names and values
        const entries: { name: string; rating: string }[] = [];

        for (const page of response.results) {
          // Type assertion for page.properties
          const pageProperties = (page as any).properties || {};

          // Find the name and number properties
          let name = "";
          let rating = "";

          for (const [propName, prop] of Object.entries(pageProperties)) {
            if (propName.toLowerCase() === "name") {
              // Get the name value
              const titleContent = (prop as any).title;
              if (titleContent && titleContent.length > 0) {
                name = titleContent
                  .map((t: any) => t.plain_text || "")
                  .join("");
              }
            } else if (propName.toLowerCase() === "number") {
              // Get the rating value
              rating = (prop as any).number?.toString() || "";
            }
          }

          if (name && rating) {
            entries.push({ name, rating });
          }
        }

        // Create a simple list format
        entries.forEach((entry) => {
          tableMarkdown += `- ${entry.name} : ${entry.rating}\n`;
        });

        // Replace the database reference with the table markdown
        // Add a newline after the list
        tableMarkdown += "\n";
        markdown = markdown.replace(match[0], tableMarkdown);

        // Clean up formatting issues
        markdown = markdown.replace(
          /\*\*Mes notes\*\*:\n- /g,
          "**Mes notes**:\n- "
        );
      } catch (dbError) {
        console.error(`Error fetching database ${databaseId}:`, dbError);
        // Replace with error message if we can't fetch the database
        markdown = markdown.replace(
          match[0],
          `**Mes notes**:\n*(Error: Could not fetch database content)*\n\n`
        );
      }
    }

    // Clean up any UUIDs/IDs that might be in the markdown
    markdown = markdown.replace(/\b[0-9a-f]{32}\b/g, '');
    markdown = markdown.trim();
    
    // Extract MIT if present
    let mit = "";
    const mitRegex = />\s*⚠️\s*\*\*MIT:\s*([^*]+)\*\*/;
    const mitMatch = markdown.match(mitRegex);
    
    if (mitMatch && mitMatch[1]) {
      mit = mitMatch[1].trim();
    }
    
    // Format for Google Docs if requested
    if (docFormat) {
      // Simple formatting for Google Docs (plain text with basic formatting)
      let docFormatted = markdown;
      
      // Replace markdown headers with plain text equivalents
      docFormatted = docFormatted.replace(/#{1,6}\s+(.+)/g, '$1');
      
      // Replace markdown bold with plain text
      docFormatted = docFormatted.replace(/\*\*(.+?)\*\*/g, '$1');
      
      // Replace markdown italic with plain text
      docFormatted = docFormatted.replace(/\*(.+?)\*/g, '$1');
      
      // Replace markdown links with just the text
      docFormatted = docFormatted.replace(/\[(.+?)\]\(.+?\)/g, '$1');
      
      // Return the formatted plain text for Google Docs
      markdown = docFormatted;
    }
    
    // Return raw markdown if requested, otherwise return JSON
    if (raw) {
      return new NextResponse(markdown, {
        headers: {
          "Content-Type": "text/plain",
        },
      });
    } else {
      return NextResponse.json({ markdown, mit });
    }
  } catch (error) {
    console.error("Error converting Notion page:", error);
    return NextResponse.json(
      { error: "Failed to convert Notion page to markdown" },
      { status: 500 }
    );
  }
}

================
File: app/api/delete-entry/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import supabase from '@/app/lib/supabase';

// Endpoint pour supprimer une entrée de journal
export async function DELETE(request: NextRequest) {
  try {
    // Récupérer l'ID de l'entrée à supprimer depuis les params de l'URL
    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');

    if (!id) {
      return NextResponse.json(
        { error: 'ID de l\'entrée requis' },
        { status: 400 }
      );
    }

    console.log(id, "id mf")

    // // Vérifier si l'ID est un UUID valide
    // if (!/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/.test(id)) {
    //   return NextResponse.json(
    //     { error: 'ID doit être un UUID valide' },
    //     { status: 400 }
    //   );
    // }

    console.log(`Suppression de l'entrée avec ID: ${id}`);

    // Supprimer l'entrée dans Supabase
    const { error } = await supabase
      .from('journal_entries')
      .delete()
      .eq('id', id);

    if (error) {
      console.error('Erreur lors de la suppression:', error);
      return NextResponse.json(
        { error: `Erreur lors de la suppression: ${error.message}` },
        { status: 500 }
      );
    }

    return NextResponse.json(
      { message: 'Entrée supprimée avec succès' },
      { status: 200 }
    );
  } catch (error) {
    console.error('Erreur:', error);
    return NextResponse.json(
      { error: 'Erreur lors de la suppression de l\'entrée', details: error instanceof Error ? error.message : String(error) },
      { status: 500 }
    );
  }
}

================
File: app/api/generate-entry/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';
import { JournalEntry } from '@/app/types';

// Initialiser OpenAI
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function POST(request: NextRequest) {
  try {
    // Récupérer le prompt vocal transcrit
    const { prompt } = await request.json();
    
    if (!prompt || typeof prompt !== 'string') {
      return NextResponse.json(
        { error: 'Un prompt est requis' },
        { status: 400 }
      );
    }
    
    // Générer l'entrée structurée avec GPT-4
    const completion = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        {
          role: 'system',
          content: `Tu es un assistant qui aide à structurer des entrées de journal.
          L'utilisateur te donne un prompt vocal décrivant sa journée, ses pensées, ou répondant à certaines questions.
          Ta tâche est de générer une entrée de journal structurée avec les champs suivants:
          1. MIT (Most Important Task): la tâche la plus importante du jour, en une phrase concise
          2. Content: le contenu principal de l'entrée, développé sur plusieurs phrases
          3. Gratitude: liste de 1 à 3 éléments dont l'utilisateur semble reconnaissant
          4. Notes: évaluation de 1 à 10 pour: productivite, sport, energie, proprete, art
          
          IMPORTANT: Pour les notes, essaie d'inférer des valeurs pertinentes basées sur le prompt. 
          Si une valeur n'est pas mentionnée, utilise 5 comme valeur par défaut.
          
          RÉPONDS UNIQUEMENT AU FORMAT JSON suivant:
          {
            "mit": "string",
            "content": "string",
            "gratitude": ["string", "string", "string"],
            "notes": {
              "productivite": number,
              "sport": number,
              "energie": number,
              "proprete": number,
              "art": number
            }
          }`
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.7,
      response_format: { type: 'json_object' }
    });
    
    // Récupérer et parser la réponse
    const responseContent = completion.choices[0].message.content;
    
    if (!responseContent) {
      throw new Error('Réponse vide de GPT');
    }
    
    const parsedResponse = JSON.parse(responseContent);
    
    // Ajouter la date du jour
    const today = new Date().toISOString().split('T')[0];
    
    // Construire l'entrée de journal
    const journalEntry: JournalEntry = {
      date: today,
      mit: parsedResponse.mit,
      content: parsedResponse.content,
      prompt: prompt,
      gratitude: parsedResponse.gratitude,
      notes: parsedResponse.notes
    };
    
    return NextResponse.json(journalEntry, { status: 200 });
  } catch (error) {
    console.error('Erreur lors de la génération de l\'entrée:', error);
    return NextResponse.json(
      { 
        error: 'Erreur lors de la génération de l\'entrée', 
        details: error instanceof Error ? error.message : String(error) 
      },
      { status: 500 }
    );
  }
}

================
File: app/api/get-last-entries/route.ts
================
import { NextResponse } from 'next/server';
import supabase from '@/app/lib/supabase';

export async function GET() {
  try {
    // Query Supabase for the 10 most recent entries
    const { data, error } = await supabase
      .from('journal_entries')
      .select('id, date, mit, content, prompt, gratitude, notes')
      .order('date', { ascending: false })
      .limit(10);
    
    if (error) {
      console.error('Error fetching recent entries:', error);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    
    return NextResponse.json(data, { status: 200 });
  } catch (error) {
    console.error('Error fetching recent entries:', error);
    return NextResponse.json(
      { error: 'Failed to fetch recent journal entries' },
      { status: 500 }
    );
  }
}

================
File: app/api/import-entries/route.ts
================
import { NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';
import { createEmbedding } from '@/app/lib/openai';
import supabase from '@/app/lib/supabase';
import { JournalEntry } from '@/app/types';

// Fonction pour lire le contenu d'un fichier
function readFileContent(filePath: string): string {
  return fs.readFileSync(filePath, 'utf8');
}

// Fonction pour extraire la date d'un nom de fichier
function extractDateFromFilename(filename: string): string | null {
  // Format attendu: entry_YYYY-MM-DD.md
  const match = filename.match(/entry_(\d{4}-\d{2}-\d{2})\.md/);
  return match ? match[1] : null;
}

// Fonction pour analyser le contenu et extraire les informations structurées
function parseEntry(content: string, date: string): JournalEntry {
  // Valeurs par défaut
  let mit = "Tâche non spécifiée";
  let gratitude: string[] = [];
  
  // Extraire MIT (première ligne non vide généralement)
  const lines = content.split('\n').filter(line => line.trim().length > 0);
  if (lines.length > 0) {
    mit = lines[0];
  }
  
  // Rechercher des mentions de gratitude
  const gratitudeRegex = /reconnaissant|gratitude|merci|apprécier|heureux de|content de/i;
  const gratitudeLines = lines.filter(line => 
    gratitudeRegex.test(line) && 
    line.length < 100 && 
    !line.includes('MIT')
  );
  
  if (gratitudeLines.length > 0) {
    gratitude = gratitudeLines.map(line => line.replace(/^[^a-zA-Z0-9]+/, '').trim());
  }
  
  // Notes
  // Par défaut, on attribue des valeurs moyennes
  const notes = {
    productivite: 5,
    sport: 5,
    energie: 5,
    proprete: 5,
    art: 5
  };
  
  // Détection de mots-clés pour ajuster les notes
  if (content.match(/productif|efficace|accompli|réussi|avancé/i)) {
    notes.productivite = 8;
  }
  if (content.match(/fatigué|épuisé|sans énergie/i)) {
    notes.energie = 3;
  } else if (content.match(/énergique|dynamique|plein d'énergie/i)) {
    notes.energie = 8;
  }
  if (content.match(/sport|entraînement|exercice|courir|gym/i)) {
    notes.sport = 7;
  }
  if (content.match(/rangé|nettoyé|propre|organisé/i)) {
    notes.proprete = 8;
  }
  if (content.match(/art|créatif|dessin|musique|peint/i)) {
    notes.art = 7;
  }
  
  return {
    date,
    mit,
    content,
    gratitude,
    notes
  };
}

export async function POST() {
  try {
    // Chemin vers le dossier des entrées
    const entriesDir = path.join(process.cwd(), 'data_journal', 'entries');
    
    // Vérifier si le dossier existe
    if (!fs.existsSync(entriesDir)) {
      return NextResponse.json({ 
        error: `Le dossier ${entriesDir} n'existe pas` 
      }, { status: 404 });
    }
    
    // Lire tous les fichiers d'entrées
    const files = fs.readdirSync(entriesDir)
                    .filter(file => file.match(/^entry_.*\.md$/));
    
    const results: string[] = [];
    let processedCount = 0;
    
    for (const file of files) {
      try {
        const filePath = path.join(entriesDir, file);
        const content = readFileContent(filePath);
        
        // Extraire la date du nom de fichier
        const date = extractDateFromFilename(file);
        
        if (!date) {
          results.push(`Fichier ignoré (pas de date): ${file}`);
          continue;
        }
        
        // Analyser le contenu pour en extraire les informations structurées
        const journalEntry = parseEntry(content, date);
        
        // Vérifier si cette entrée existe déjà
        const { data: existingEntries, error: checkError } = await supabase
          .from('journal_entries')
          .select('id')
          .eq('date', date);
        
        if (checkError) {
          results.push(`Erreur lors de la vérification pour ${file}: ${checkError.message}`);
          continue;
        }
        
        // Si l'entrée existe déjà, la sauter
        if (existingEntries && existingEntries.length > 0) {
          results.push(`Entrée ignorée (déjà existante pour ${date}): ${file}`);
          continue;
        }
        
        // Créer l'embedding pour cette entrée
        const textToEmbed = `${journalEntry.mit} ${journalEntry.content} ${journalEntry.gratitude.join(' ')}`;
        const embedding = await createEmbedding(textToEmbed);
        
        // Insérer l'entrée dans Supabase
        const { error } = await supabase
          .from('journal_entries')
          .insert({
            ...journalEntry,
            embedding
          });
        
        if (error) {
          results.push(`Erreur lors de l'insertion pour ${file}: ${error.message}`);
        } else {
          results.push(`Entrée importée avec succès: ${file}`);
          processedCount++;
        }
      } catch (err) {
        results.push(`Erreur lors du traitement de ${file}: ${err instanceof Error ? err.message : String(err)}`);
      }
    }
    
    return NextResponse.json({
      message: `Traitement terminé: ${processedCount} entrées importées sur ${files.length} fichiers traités`,
      processed: processedCount,
      total: files.length,
      results
    });
  } catch (error) {
    console.error('Erreur lors de l\'importation des entrées:', error);
    return NextResponse.json(
      { 
        error: 'Erreur lors de l\'importation des entrées', 
        details: error instanceof Error ? error.message : String(error) 
      },
      { status: 500 }
    );
  }
}

================
File: app/api/regenerate-embeddings/route.ts
================
import { NextResponse } from 'next/server';
import supabase from '@/app/lib/supabase';
import { createEmbedding } from '@/app/lib/openai';
import { JournalEntry } from '@/app/types';

export async function GET() {
  try {
    // Fetch all entries without embeddings
    const { data: entries, error: fetchError } = await supabase
      .from('journal_entries')
      .select('*');
    
    if (fetchError) {
      console.error('Error fetching entries:', fetchError);
      return NextResponse.json({ error: fetchError.message }, { status: 500 });
    }
    
    if (!entries || entries.length === 0) {
      return NextResponse.json({ message: 'No entries found to process' }, { status: 200 });
    }
    
    console.log(`Found ${entries.length} entries to process`);
    
    // Process entries in batches to avoid rate limiting
    const batchSize = 5;
    const results: Array<{
      id: string | undefined;
      success: boolean;
      error?: string;
      date: string;
      mit?: string;
    }> = [];
    let successCount = 0;
    let errorCount = 0;
    
    for (let i = 0; i < entries.length; i += batchSize) {
      const batch = entries.slice(i, i + batchSize);
      console.log(`Processing batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(entries.length/batchSize)}, entries ${i+1}-${Math.min(i+batchSize, entries.length)}`);
      
      const batchResults = await Promise.all(batch.map(async (entry: JournalEntry) => {
        try {
          // Create text to embed
          let textToEmbed = `${entry.mit || ''} ${entry.content || ''} ${entry.prompt || ''}`;

          // Ajouter la gratitude au texte à encoder, en gérant les différents formats possibles
          if (entry.gratitude) {
            if (Array.isArray(entry.gratitude)) {
              // Format ancien (tableau de chaînes)
              textToEmbed += ' ' + entry.gratitude.join(' ');
            } else if (typeof entry.gratitude === 'object') {
              // Format nouveau (jsonb)
              try {
                const gratitudeValues = Object.values(entry.gratitude);
                textToEmbed += ' ' + gratitudeValues.join(' ');
              } catch (e) {
                console.warn(`Erreur lors du traitement de gratitude pour l'entrée ${entry.id}:`, e);
              }
            } else if (typeof entry.gratitude === 'string') {
              // Cas où c'est une chaîne simple
              textToEmbed += ' ' + entry.gratitude;
            }
          }
          
          if (!textToEmbed.trim()) {
            console.warn(`Entry ${entry.id} (${entry.date}) has no content to embed`);
            return { id: entry.id, success: false, error: 'No content to embed', date: entry.date };
          }
          
          // Generate embedding
          const embedding = await createEmbedding(textToEmbed);
          
          // Update entry with embedding
          const { error } = await supabase
            .from('journal_entries')
            .update({ embedding })
            .eq('id', entry.id)
            .select('id, date, mit');
          
          if (error) {
            console.error(`Error updating entry ${entry.id}:`, error);
            errorCount++;
            return { id: entry.id, success: false, error: error.message, date: entry.date };
          }
          
          successCount++;
          return { id: entry.id, success: true, date: entry.date, mit: entry.mit };
        } catch (err) {
          console.error(`Error processing entry ${entry.id}:`, err);
          errorCount++;
          return { id: entry.id, success: false, error: err instanceof Error ? err.message : 'Unknown error', date: entry.date };
        }
      }));
      
      results.push(...batchResults);
      
      // Add a small delay between batches to avoid rate limiting
      if (i + batchSize < entries.length) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
    
    return NextResponse.json({
      message: `Processed ${entries.length} entries. Successfully updated ${successCount} embeddings. ${errorCount} errors.`,
      results
    }, { status: 200 });
  } catch (error) {
    console.error('Error regenerating embeddings:', error);
    return NextResponse.json(
      { error: 'Failed to regenerate embeddings', details: error instanceof Error ? error.message : String(error) },
      { status: 500 }
    );
  }
}

================
File: app/api/transcribe/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';

// Initialiser OpenAI
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function POST(request: NextRequest) {
  try {
    // Récupérer le fichier audio de la requête
    const formData = await request.formData();
    const audioFile = formData.get('audio') as File;
    
    if (!audioFile) {
      return NextResponse.json(
        { error: 'Fichier audio requis' },
        { status: 400 }
      );
    }

    // Vérifier le type de fichier audio
    const buffer = await audioFile.arrayBuffer();
    const fileBlob = new Blob([buffer], { type: 'audio/webm' });
    
    // Convertir le Blob en fichier avec extension explicite
    const fileName = 'recording.webm';
    const fileObject = new File([fileBlob], fileName, { type: 'audio/webm' });
    
    // Log pour le débogage
    console.log(`Fichier préparé pour transcription: ${fileName}, type: ${fileObject.type}, taille: ${fileObject.size} bytes`);
    
    // Tester d'abord avec le nouveau modèle GPT-4o-mini-transcribe
    try {
      const transcription = await openai.audio.transcriptions.create({
        file: fileObject,
        model: 'gpt-4o-mini-transcribe',
        response_format: 'text',
      });
      
      return NextResponse.json({
        text: transcription,
        model: 'gpt-4o-mini-transcribe'
      }, { status: 200 });
    } catch (newModelError) {
      console.warn('Erreur avec le modèle gpt-4o-mini-transcribe, fallback sur whisper-1:', newModelError);
      
      // Fallback sur le modèle whisper-1 si le nouveau modèle n'est pas disponible
      const transcription = await openai.audio.transcriptions.create({
        file: fileObject,
        model: 'whisper-1',
        response_format: 'json',
      });
      
      return NextResponse.json({
        text: transcription.text,
        model: 'whisper-1'
      }, { status: 200 });
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('Erreur lors de la transcription:', error);
    
    // Retourner un message d'erreur plus détaillé
    return NextResponse.json(
      { 
        error: 'Erreur lors de la transcription', 
        details: errorMessage 
      },
      { status: 500 }
    );
  }
}

================
File: app/ask/page.tsx
================
'use client';

import { useState } from 'react';
import { Navigation } from '@/components/navigation';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Textarea } from '@/components/ui/textarea';

export default function Ask() {
  const [question, setQuestion] = useState('');
  const [answer, setAnswer] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!question.trim()) {
      setError('Veuillez saisir une question');
      return;
    }
    
    setIsSubmitting(true);
    setError('');
    setAnswer('');

    try {
      const response = await fetch('/api/ask', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ question }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Une erreur est survenue');
      }

      setAnswer(data.answer);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Une erreur est survenue');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <main className="flex min-h-screen flex-col items-center p-8">
      <div className="max-w-4xl w-full">
        <h1 className="text-4xl font-bold mb-8 text-center">Interroger mon journal</h1>
        
        <Navigation />
        
        <div className="space-y-8">
          <Card>
            <CardHeader>
              <CardTitle>Posez une question à votre journal</CardTitle>
            </CardHeader>
            <CardContent>
              {error && (
                <div className="mb-4 p-4 bg-red-100 text-red-700 rounded-md">
                  {error}
                </div>
              )}
              
              <form onSubmit={handleSubmit} className="space-y-4">
                <div className="space-y-2">
                  <label htmlFor="question" className="text-sm font-medium">
                    Votre question
                  </label>
                  <Textarea
                    id="question"
                    value={question}
                    onChange={(e) => setQuestion(e.target.value)}
                    placeholder="Par exemple : Quelles ont été mes périodes les plus productives cette année ?"
                    rows={3}
                    className="resize-none"
                  />
                </div>
                
                <Button 
                  type="submit" 
                  disabled={isSubmitting} 
                  className="w-full"
                >
                  {isSubmitting ? 'Analyse en cours...' : 'Obtenir une réponse'}
                </Button>
              </form>
            </CardContent>
          </Card>
          
          {answer && (
            <Card>
              <CardHeader>
                <CardTitle>Réponse basée sur votre journal</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="whitespace-pre-line text-gray-800">
                  {answer}
                </div>
              </CardContent>
            </Card>
          )}
          
          <div className="text-sm text-gray-500 text-center">
            <p>Cette fonctionnalité utilise la recherche vectorielle pour trouver les entrées pertinentes et GPT pour les analyser</p>
          </div>
        </div>
      </div>
    </main>
  );
}

================
File: app/entries/page.tsx
================
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { Navigation } from '@/components/navigation';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { JournalEntry } from '@/app/types';
import { Button } from '@/components/ui/button';
import { Trash2 } from 'lucide-react';
import { 
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";

export default function Entries() {
  const router = useRouter();
  const [entries, setEntries] = useState<JournalEntry[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isBuildingEmbeddings, setIsBuildingEmbeddings] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);
  const [embedMessage, setEmbedMessage] = useState('');
  const [deleteMessage, setDeleteMessage] = useState('');
  const [error, setError] = useState('');

  const fetchEntries = async () => {
    try {
      setIsLoading(true);
      const response = await fetch('/api/get-last-entries');
      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Erreur lors de la récupération des entrées');
      }

      setEntries(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Une erreur est survenue');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchEntries();
  }, []);

  const deleteEntry = async (id: string) => {
    try {
      setIsDeleting(true);
      setDeleteMessage('');
      
      const response = await fetch(`/api/delete-entry?id=${id}`, {
        method: 'DELETE',
      });
      
      const data = await response.json();
      
      if (!response.ok) {
        throw new Error(data.error || 'Erreur lors de la suppression');
      }
      
      // Supprimer l'entrée du state local
      setEntries(entries.filter(entry => entry.id !== id));
      
      // Afficher un message de succès
      setDeleteMessage('Entrée supprimée avec succès');
      setTimeout(() => {
        setDeleteMessage('');
      }, 3000);
      
    } catch (err) {
      console.error('Erreur:', err);
      setError(err instanceof Error ? err.message : 'Une erreur est survenue');
    } finally {
      setIsDeleting(false);
    }
  };

  // Format a note to show as a progress bar with label
  const formatNote = (value: number, label: string) => (
    <div className="space-y-1" key={label}>
      <div className="flex items-center justify-between text-xs">
        <span>{label}</span>
        <span>{value}/10</span>
      </div>
      <div className="h-2 bg-gray-200 rounded-full overflow-hidden">
        <div 
          className="h-full bg-blue-500 rounded-full" 
          style={{ width: `${value * 10}%` }}
        ></div>
      </div>
    </div>
  );

  const regenerateEmbeddings = async () => {
    try {
      setIsBuildingEmbeddings(true);
      setEmbedMessage('Régénération des embeddings en cours...');
      
      const response = await fetch('/api/regenerate-embeddings', {
        method: 'GET'
      });
      
      if (!response.ok) {
        throw new Error('Erreur lors de la régénération des embeddings');
      }
      
      const data = await response.json();
      setEmbedMessage(`Embeddings régénérés avec succès ! ${data.message}`);
    } catch (error) {
      setEmbedMessage(`Erreur: ${error instanceof Error ? error.message : String(error)}`);
    } finally {
      setIsBuildingEmbeddings(false);
    }
  };

  return (
    <main className="flex min-h-screen flex-col items-center p-8">
      <div className="max-w-4xl w-full">
        <div className="flex justify-between items-center mb-6">
          <h1 className="text-3xl font-bold">Dernières Entrées</h1>
          <div className="space-x-2">
            <Button 
              onClick={regenerateEmbeddings} 
              disabled={isBuildingEmbeddings}
              variant="outline"
              size="sm"
            >
              {isBuildingEmbeddings ? 'Traitement...' : 'Régénérer Embeddings'}
            </Button>
            <Button variant="default" onClick={() => router.push('/add-entry')}>
              Nouvelle Entrée
            </Button>
          </div>
        </div>
        
        {embedMessage && (
          <div className={`p-4 mb-4 rounded ${embedMessage.includes('Erreur') ? 'bg-red-100 text-red-800' : 'bg-green-100 text-green-800'}`}>
            {embedMessage}
          </div>
        )}
        
        {deleteMessage && (
          <div className="bg-green-100 text-green-800 px-4 py-2 mb-4 rounded-md">
            {deleteMessage}
          </div>
        )}
        
        <Navigation />
        
        {isLoading && (
          <div className="flex justify-center p-12">
            <div className="animate-spin h-8 w-8 border-4 border-blue-500 rounded-full border-t-transparent"></div>
          </div>
        )}
        
        {error && (
          <div className="mb-6 p-4 bg-red-100 border-l-4 border-red-500 text-red-700 rounded-md">
            <p>{error}</p>
          </div>
        )}
        
        {!isLoading && !error && entries.length === 0 && (
          <div className="text-center p-12">
            <p className="text-lg text-gray-600">Aucune entrée trouvée. Commencez par ajouter votre première entrée.</p>
          </div>
        )}
        
        <div className="space-y-6">
          {entries.map((entry, index) => (
            <Card key={entry.id || `entry-${index}`} className="overflow-hidden">
              <CardHeader className="bg-gray-50">
                <div className="flex justify-between items-start">
                  <CardTitle className="text-xl">{new Date(entry.date).toLocaleDateString('fr-FR', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}</CardTitle>
                  <div className="flex items-center space-x-2">
                    <span className="text-sm text-gray-500">{entry.date}</span>
                    <AlertDialog>
                      <AlertDialogTrigger asChild>
                        <Button 
                          variant="ghost" 
                          size="icon" 
                          className="text-red-500 hover:text-red-700 hover:bg-red-50"
                        >
                          <Trash2 size={18} />
                        </Button>
                      </AlertDialogTrigger>
                      <AlertDialogContent>
                        <AlertDialogHeader>
                          <AlertDialogTitle>Êtes-vous sûr de vouloir supprimer cette entrée ?</AlertDialogTitle>
                          <AlertDialogDescription>
                            Cette action est irréversible. L&apos;entrée du {new Date(entry.date).toLocaleDateString('fr-FR')} sera définitivement supprimée.
                          </AlertDialogDescription>
                        </AlertDialogHeader>
                        <AlertDialogFooter>
                          <AlertDialogCancel>Annuler</AlertDialogCancel>
                          <AlertDialogAction 
                            className="bg-red-500 hover:bg-red-600"
                            onClick={() => deleteEntry(entry.id || '')}
                            disabled={isDeleting || !entry.id}
                          >
                            {isDeleting ? 'Suppression...' : 'Supprimer'}
                          </AlertDialogAction>
                        </AlertDialogFooter>
                      </AlertDialogContent>
                    </AlertDialog>
                  </div>
                </div>
              </CardHeader>
              <CardContent className="pt-6">
                <div className="space-y-6">
                  <div>
                    <h3 className="font-medium mb-2">Most Important Task</h3>
                    <p className="text-gray-800">{entry.mit}</p>
                  </div>
                  
                  {entry.prompt && (
                    <div>
                      <h3 className="font-medium mb-2">Prompt</h3>
                      <p className="text-gray-600 italic">{entry.prompt}</p>
                    </div>
                  )}
                  
                  <div>
                    <h3 className="font-medium mb-2">Contenu</h3>
                    <p className="text-gray-800 whitespace-pre-line">{entry.content}</p>
                  </div>
                  
                  {entry.gratitude && entry.gratitude.length > 0 && (
                    <div>
                      <h3 className="font-medium mb-2">Gratitude</h3>
                      <ul className="list-disc pl-5 space-y-1">
                        {entry.gratitude.map((item, i) => (
                          <li key={`${entry.id}-gratitude-${i}`} className="text-gray-800">{item}</li>
                        ))}
                      </ul>
                    </div>
                  )}
                  
                  {entry.notes && (
                    <div>
                      <h3 className="font-medium mb-3">Notes</h3>
                      <div className="space-y-3">
                        {entry.notes.productivite !== undefined && formatNote(entry.notes.productivite, 'Productivité')}
                        {entry.notes.sport !== undefined && formatNote(entry.notes.sport, 'Sport')}
                        {entry.notes.energie !== undefined && formatNote(entry.notes.energie, 'Énergie')}
                        {entry.notes.proprete !== undefined && formatNote(entry.notes.proprete, 'Propreté')}
                        {entry.notes.art !== undefined && formatNote(entry.notes.art, 'Art')}
                      </div>
                    </div>
                  )}
                </div>
              </CardContent>
            </Card>
          ))}
        </div>
      </div>
    </main>
  );
}

================
File: app/generate-entry/page.tsx
================
'use client';

import { useState } from 'react';
import { Navigation } from '@/components/navigation';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { JournalEntry } from '@/app/types';
import { TextWithAudio } from '@/components/TextWithAudio';

export default function GenerateEntry() {
  const [prompt, setPrompt] = useState('');
  const [isGenerating, setIsGenerating] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState('');
  const [generatedEntry, setGeneratedEntry] = useState<JournalEntry | null>(null);
  const [editedEntry, setEditedEntry] = useState<JournalEntry | null>(null);
  
  // Fonction pour générer l'entrée de journal
  const generateEntry = async (promptText: string) => {
    try {
      setIsGenerating(true);
      setError('');
      
      const response = await fetch('/api/generate-entry', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ prompt: promptText }),
      });
      
      const data = await response.json();
      
      if (!response.ok) {
        throw new Error(data.error || 'Erreur lors de la génération de l&apos;entrée');
      }
      
      setGeneratedEntry(data);
      setEditedEntry(data);
    } catch (err) {
      console.error('Erreur lors de la génération:', err);
      setError(err instanceof Error ? err.message : 'Une erreur est survenue');
    } finally {
      setIsGenerating(false);
    }
  };
  
  // Gérer les modifications des champs
  const handleFieldChange = (field: string, value: any) => {
    if (!editedEntry) return;
    
    setEditedEntry((prev: JournalEntry | null) => {
      if (!prev) return prev;
      
      if (field === 'mit' || field === 'content' || field === 'date') {
        return { ...prev, [field]: value } as JournalEntry;
      } else if (field.startsWith('notes.')) {
        const noteField = field.split('.')[1];
        return {
          ...prev,
          notes: {
            ...(prev.notes || {}),
            [noteField]: parseInt(value)
          }
        } as JournalEntry;
      } else if (field.startsWith('gratitude.')) {
        const index = parseInt(field.split('.')[1]);
        const newGratitude = [...prev.gratitude];
        newGratitude[index] = value;
        return { ...prev, gratitude: newGratitude };
      }
      
      return prev;
    });
  };
  
  // Soumettre l'entrée finale
  const submitEntry = async () => {
    if (!editedEntry) return;
    
    try {
      setIsSubmitting(true);
      setError('');
      
      const response = await fetch('/api/add-entry', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(editedEntry),
      });
      
      const data = await response.json();
      
      if (!response.ok) {
        throw new Error(data.error || 'Erreur lors de l&apos;enregistrement de l&apos;entrée');
      }
      
      // Afficher un message de succès mais ne pas rediriger automatiquement
      setError('');
      alert('Entrée sauvegardée avec succès!');
      
      // Réinitialiser le formulaire
      setPrompt('');
      setGeneratedEntry(null);
      setEditedEntry(null);
    } catch (err) {
      console.error('Erreur lors de l&apos;enregistrement:', err);
      setError(err instanceof Error ? err.message : 'Une erreur est survenue');
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <main className="flex min-h-screen flex-col items-center p-8">
      <div className="max-w-4xl w-full">
        <h1 className="text-4xl font-bold mb-8 text-center">Générer une entrée</h1>
        
        <Navigation />
        
        {!generatedEntry ? (
          <Card>
            <CardHeader>
              <CardTitle>Racontez votre journée</CardTitle>
              <CardDescription>
                Parlez de votre journée et nous générerons une entrée de journal structurée
              </CardDescription>
            </CardHeader>
            <CardContent>
              {error && (
                <div className="mb-4 p-4 bg-red-100 text-red-700 rounded-md">
                  {error}
                </div>
              )}
              
              <div className="space-y-6">
                <div className="space-y-2">
                  <label htmlFor="prompt" className="text-sm font-medium">
                    Décrivez votre journée ou répondez à ces questions:
                  </label>
                  <div className="text-sm text-gray-500 mb-2">
                    <ul className="list-disc pl-5 space-y-1">
                      <li>Qu&apos;avez-vous accompli aujourd&apos;hui?</li>
                      <li>Pour quoi êtes-vous reconnaissant(e)?</li>
                      <li>Comment évalueriez-vous votre énergie et productivité?</li>
                      <li>Avez-vous fait du sport ou pratiqué un art?</li>
                    </ul>
                  </div>
                  <TextWithAudio
                    id="prompt"
                    value={prompt}
                    onChange={setPrompt}
                    placeholder="Aujourd&apos;hui j&apos;ai..."
                    rows={8}
                    isTextarea={true}
                  />
                </div>
                
                <div className="flex justify-end">
                  <Button 
                    type="button" 
                    className="w-full md:w-auto"
                    disabled={!prompt || isGenerating}
                    onClick={() => generateEntry(prompt)}
                  >
                    {isGenerating ? 'Génération en cours...' : 'Générer l&apos;entrée'}
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>
        ) : (
          <Card>
            <CardHeader>
              <CardTitle>Entrée générée</CardTitle>
              <CardDescription>
                Vérifiez et modifiez l&apos;entrée avant de la sauvegarder
              </CardDescription>
            </CardHeader>
            <CardContent>
              {error && (
                <div className="mb-4 p-4 bg-red-100 text-red-700 rounded-md">
                  {error}
                </div>
              )}
              
              <form className="space-y-6">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div className="space-y-2">
                    <label htmlFor="date" className="text-sm font-medium">
                      Date
                    </label>
                    <Input
                      id="date"
                      type="date"
                      value={editedEntry?.date || ''}
                      onChange={(e) => handleFieldChange('date', e.target.value)}
                      required
                    />
                  </div>
                  
                  <div className="space-y-2">
                    <label htmlFor="mit" className="text-sm font-medium">
                      Tâche la plus importante (MIT)
                    </label>
                    <TextWithAudio
                      id="mit"
                      value={editedEntry?.mit || ''}
                      onChange={(value) => handleFieldChange('mit', value)}
                      placeholder="Tâche la plus importante"
                      isTextarea={false}
                    />
                  </div>
                </div>
                
                <div className="space-y-2">
                  <label htmlFor="content" className="text-sm font-medium">
                    Contenu
                  </label>
                  <TextWithAudio
                    id="content"
                    value={editedEntry?.content || ''}
                    onChange={(value) => handleFieldChange('content', value)}
                    rows={6}
                  />
                </div>
                
                <div className="space-y-2">
                  <label className="text-sm font-medium">
                    Gratitude
                  </label>
                  <div className="space-y-2">
                    {editedEntry?.gratitude?.map((item, index) => (
                      <TextWithAudio
                        key={index}
                        value={item}
                        onChange={(value) => handleFieldChange(`gratitude.${index}`, value)}
                        placeholder={`Gratitude ${index + 1}`}
                        isTextarea={false}
                      />
                    ))}
                  </div>
                </div>
                
                <div className="space-y-4">
                  <h3 className="text-sm font-medium">Notes (1-10)</h3>
                  
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    {editedEntry?.notes && Object.entries(editedEntry.notes).map(([key, value]) => (
                      <div className="space-y-2" key={key}>
                        <div className="flex justify-between">
                          <label htmlFor={key} className="text-sm capitalize">
                            {key}
                          </label>
                          <span>{value}/10</span>
                        </div>
                        <Input
                          id={key}
                          type="range"
                          min="1"
                          max="10"
                          value={value}
                          onChange={(e) => handleFieldChange(`notes.${key}`, e.target.value)}
                        />
                      </div>
                    ))}
                  </div>
                </div>
                
                <div className="flex gap-3">
                  <Button 
                    type="button" 
                    variant="outline"
                    onClick={() => {
                      setGeneratedEntry(null);
                      setEditedEntry(null);
                    }}
                  >
                    Annuler
                  </Button>
                  
                  <Button 
                    type="button" 
                    className="flex-1"
                    disabled={isSubmitting}
                    onClick={submitEntry}
                  >
                    {isSubmitting ? 'Enregistrement...' : 'Sauvegarder l&apos;entrée'}
                  </Button>
                </div>
              </form>
            </CardContent>
          </Card>
        )}
      </div>
    </main>
  );
}

================
File: app/globals.css
================
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

/* Markdown Preview Styles */
.markdown-preview {
  line-height: 1.6;
}

.markdown-preview h1,
.markdown-preview h2,
.markdown-preview h3,
.markdown-preview h4,
.markdown-preview h5,
.markdown-preview h6 {
  margin-top: 1em;
  margin-bottom: 0.5em;
  font-weight: 600;
}

.markdown-preview h1 {
  font-size: 2em;
}

.markdown-preview h2 {
  font-size: 1.75em;
}

.markdown-preview h3 {
  font-size: 1.5em;
}

.markdown-preview p {
  margin-bottom: 0.8em;
}

.markdown-preview ul,
.markdown-preview ol {
  padding-left: 1.5em;
  margin-bottom: 1.2em;
}

.markdown-preview li {
  margin-bottom: 0.5em;
}

.markdown-preview blockquote {
  border-left: 4px solid #e5e7eb;
  padding-left: 1em;
  margin-left: 0;
  margin-right: 0;
  margin-bottom: 1em;
  /* Removed italic styling and gray color */
}

.markdown-preview hr {
  margin: 2em 0;
  border: 0;
  border-top: 1px solid #e5e7eb;
}

.markdown-preview table {
  border-collapse: collapse;
  width: 100%;
  margin-bottom: 1.2em;
}

.markdown-preview th,
.markdown-preview td {
  border: 1px solid #e5e7eb;
  padding: 0.5em;
  text-align: left;
}

.markdown-preview th {
  background-color: #f9fafb;
}

/* Special styling for Mes notes section */
.markdown-preview:has(h1:first-of-type) h1:first-of-type {
  margin-top: 0;
}

.markdown-preview p:has(strong) {
  margin-top: 2em;
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.141 0.005 285.823);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.141 0.005 285.823);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.141 0.005 285.823);
  --primary: oklch(0.21 0.006 285.885);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.967 0.001 286.375);
  --secondary-foreground: oklch(0.21 0.006 285.885);
  --muted: oklch(0.967 0.001 286.375);
  --muted-foreground: oklch(0.552 0.016 285.938);
  --accent: oklch(0.967 0.001 286.375);
  --accent-foreground: oklch(0.21 0.006 285.885);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.92 0.004 286.32);
  --input: oklch(0.92 0.004 286.32);
  --ring: oklch(0.705 0.015 286.067);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.141 0.005 285.823);
  --sidebar-primary: oklch(0.21 0.006 285.885);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.967 0.001 286.375);
  --sidebar-accent-foreground: oklch(0.21 0.006 285.885);
  --sidebar-border: oklch(0.92 0.004 286.32);
  --sidebar-ring: oklch(0.705 0.015 286.067);
}

.dark {
  --background: oklch(0.141 0.005 285.823);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.21 0.006 285.885);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.21 0.006 285.885);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.92 0.004 286.32);
  --primary-foreground: oklch(0.21 0.006 285.885);
  --secondary: oklch(0.274 0.006 286.033);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.274 0.006 286.033);
  --muted-foreground: oklch(0.705 0.015 286.067);
  --accent: oklch(0.274 0.006 286.033);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.552 0.016 285.938);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.21 0.006 285.885);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.274 0.006 286.033);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.552 0.016 285.938);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

================
File: app/import/page.tsx
================
'use client';

import { useState } from 'react';
import { Navigation } from '@/components/navigation';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from '@/components/ui/card';

export default function Import() {
  const [isProcessing, setIsProcessing] = useState(false);
  const [results, setResults] = useState<string[]>([]);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  
  // Traiter les entrées existantes
  const processEntries = async () => {
    try {
      setIsProcessing(true);
      setError('');
      setSuccess('');
      setResults(['Démarrage du traitement des entrées...']);
      
      // Appeler l'API pour traiter les entrées
      const response = await fetch('/api/import-entries', {
        method: 'POST'
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Erreur lors du traitement');
      }
      
      const data = await response.json();
      
      if (data.results && Array.isArray(data.results)) {
        setResults(prev => [...prev, ...data.results]);
      }
      
      setSuccess(`Traitement terminé avec succès: ${data.processed} entrées traitées`);
    } catch (err) {
      console.error('Erreur:', err);
      setError(err instanceof Error ? err.message : 'Une erreur est survenue');
    } finally {
      setIsProcessing(false);
    }
  };
  
  // Générer des embeddings pour toutes les entrées
  const generateEmbeddings = async () => {
    try {
      setIsProcessing(true);
      setError('');
      setSuccess('');
      setResults(['Démarrage de la génération des embeddings...']);
      
      // Appeler l'API pour générer les embeddings
      const response = await fetch('/api/regenerate-embeddings', {
        method: 'GET'
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Erreur lors de la génération des embeddings');
      }
      
      const data = await response.json();
      
      setResults(prev => [...prev, `Génération terminée: ${data.message}`]);
      setSuccess('Embeddings générés avec succès');
    } catch (err) {
      console.error('Erreur:', err);
      setError(err instanceof Error ? err.message : 'Une erreur est survenue');
    } finally {
      setIsProcessing(false);
    }
  };
  
  return (
    <main className="flex min-h-screen flex-col items-center p-8">
      <div className="max-w-4xl w-full">
        <h1 className="text-4xl font-bold mb-8 text-center">Importation et Traitement</h1>
        
        <Navigation />
        
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
          <Card>
            <CardHeader>
              <CardTitle>Importer depuis Notion</CardTitle>
              <CardDescription>
                Importe et traite les entrées depuis les fichiers Notion
              </CardDescription>
            </CardHeader>
            <CardContent>
              <p className="text-sm text-gray-500 mb-4">
                Cette fonction traitera les entrées existantes dans votre dossier de données
                pour les rendre compatibles avec la recherche vectorielle.
              </p>
            </CardContent>
            <CardFooter>
              <Button 
                onClick={processEntries}
                disabled={isProcessing}
                className="w-full"
              >
                {isProcessing ? 'Traitement en cours...' : 'Importer les entrées'}
              </Button>
            </CardFooter>
          </Card>
          
          <Card>
            <CardHeader>
              <CardTitle>Générer les Embeddings</CardTitle>
              <CardDescription>
                Génère des embeddings vectoriels pour la recherche
              </CardDescription>
            </CardHeader>
            <CardContent>
              <p className="text-sm text-gray-500 mb-4">
                Cette fonction créera des embeddings vectoriels pour toutes vos entrées,
                permettant ainsi la recherche sémantique et l&apos;analyse IA.
              </p>
            </CardContent>
            <CardFooter>
              <Button 
                onClick={generateEmbeddings}
                disabled={isProcessing}
                className="w-full"
              >
                {isProcessing ? 'Génération en cours...' : 'Générer les Embeddings'}
              </Button>
            </CardFooter>
          </Card>
        </div>
        
        {error && (
          <div className="mb-6 p-4 bg-red-100 text-red-700 rounded-md">
            {error}
          </div>
        )}
        
        {success && (
          <div className="mb-6 p-4 bg-green-100 text-green-700 rounded-md">
            {success}
          </div>
        )}
        
        {results.length > 0 && (
          <Card>
            <CardHeader>
              <CardTitle>Résultats du traitement</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="bg-gray-100 p-4 rounded-md max-h-80 overflow-y-auto">
                {results.map((result, index) => (
                  <div key={index} className="mb-1">
                    {result}
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        )}
      </div>
    </main>
  );
}

================
File: app/layout.tsx
================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}

================
File: app/lib/openai.ts
================
import OpenAI from 'openai';

if (!process.env.OPENAI_API_KEY) {
  throw new Error('Missing OpenAI API Key');
}

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function createEmbedding(text: string): Promise<number[]> {
  const response = await openai.embeddings.create({
    model: 'text-embedding-3-small',
    input: text,
    encoding_format: 'float',
  });
  
  return response.data[0].embedding;
}

export async function generateCompletion(prompt: string): Promise<string> {
  const response = await openai.chat.completions.create({
    model: 'gpt-4o',
    messages: [
      {
        role: 'system',
        content: 'You are a helpful assistant analyzing journal entries and providing insights.',
      },
      {
        role: 'user',
        content: prompt,
      },
    ],
    temperature: 0.7,
    max_tokens: 1000,
  });
  
  return response.choices[0].message.content || '';
}

export default openai;

================
File: app/lib/supabase.ts
================
import { createClient } from '@supabase/supabase-js';
import { Database } from '../types';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL as string;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY as string;

if (!supabaseUrl || !supabaseServiceKey) {
  throw new Error('Missing Supabase environment variables');
}

// Create Supabase client with service role key
const supabase = createClient<Database>(supabaseUrl, supabaseServiceKey);

export default supabase;

================
File: app/page.tsx
================
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Navigation } from "@/components/navigation";
import Link from "next/link";
import { Button } from "@/components/ui/button";

export default function Home() {
  return (
    <main className="flex min-h-screen flex-col items-center p-8">
      <div className="max-w-4xl w-full">
        <h1 className="text-4xl font-bold mb-8 text-center">Journal Personnel</h1>
        
        <Navigation />
        
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          <Card>
            <CardHeader>
              <CardTitle>Ajouter une entrée</CardTitle>
              <CardDescription>Créez une nouvelle entrée de journal</CardDescription>
            </CardHeader>
            <CardContent>
              <p className="mb-4 text-sm">Enregistrez vos pensées, objectifs et réflexions du jour.</p>
              <Button asChild className="w-full">
                <Link href="/add-entry">Commencer</Link>
              </Button>
            </CardContent>
          </Card>
          
          <Card>
            <CardHeader>
              <CardTitle>Dernières entrées</CardTitle>
              <CardDescription>Consultez vos entrées récentes</CardDescription>
            </CardHeader>
            <CardContent>
              <p className="mb-4 text-sm">Affichez les 10 dernières entrées de votre journal personnel.</p>
              <Button asChild variant="outline" className="w-full">
                <Link href="/entries">Consulter</Link>
              </Button>
            </CardContent>
          </Card>
          
          <Card>
            <CardHeader>
              <CardTitle>Poser une question</CardTitle>
              <CardDescription>Interrogez votre journal</CardDescription>
            </CardHeader>
            <CardContent>
              <p className="mb-4 text-sm">Utilisez l&apos;IA pour analyser vos entrées et obtenir des insights.</p>
              <Button asChild variant="outline" className="w-full">
                <Link href="/ask">Demander</Link>
              </Button>
            </CardContent>
          </Card>
        </div>
      </div>
    </main>
  );
}

================
File: app/types/index.ts
================
export interface JournalEntry {
  id?: string;
  date: string;
  mit: string;
  content: string;
  prompt?: string;
  gratitude?: any; // Changé de string[] à any pour supporter le format jsonb
  notes?: {
    productivite?: number;
    sport?: number;
    energie?: number;
    proprete?: number;
    art?: number;
  };
  embedding?: number[];
  created_at?: string;
  similarity?: number; // Ajouté pour le support des résultats de recherche vectorielle
}

export interface AskQuestion {
  question: string;
}

export interface Database {
  public: {
    Tables: {
      journal_entries: {
        Row: JournalEntry;
        Insert: Omit<JournalEntry, 'id' | 'created_at'>;
        Update: Partial<Omit<JournalEntry, 'id' | 'created_at'>>;
      };
    };
  };
}

================
File: bluerint-fixed.json
================
{
  "name": "Airtable → Supabase JSONB",
  "flow": [
    {
      "id": 1,
      "module": "airtable:ActionSearchRecords",
      "version": 3,
      "parameters": {
        "__IMTCONN__": 3163234
      },
      "mapper": {
        "base": "appeIZyIpK8s2w7zK",
        "useColumnId": false,
        "table": "tblBYVBWsKevT3PKl",
        "maxRecords": "1"
      },
      "metadata": {
        "designer": {
          "x": -300,
          "y": 0
        }
      }
    },
    {
      "id": 2,
      "module": "util:SetVariable2",
      "version": 1,
      "parameters": {},
      "mapper": {
        "name": "notesObject",
        "scope": "roundtrip",
        "value": {
          "art": "{{1.art}}",
          "sport": "{{1.sport}}",
          "energie": "{{1.energie}}",
          "proprete": "{{1.propreté}}",
          "productivite": "{{1.productivité}}"
        }
      },
      "metadata": {
        "designer": {
          "x": 0,
          "y": -100
        },
        "notes": "Cette étape crée un objet structuré pour le champ notes: {art: 1, sport: 10, ...}"
      }
    },
    {
      "id": 3,
      "module": "util:SetVariable2",
      "version": 1,
      "parameters": {},
      "mapper": {
        "name": "gratitudeArray",
        "scope": "roundtrip",
        "value": "{{map(split(1.gratitude; \",\"); (item) -> trim(item))}}"
      },
      "metadata": {
        "designer": {
          "x": 0,
          "y": 120
        }
      }
    },
    {
      "id": 4,
      "module": "supabase:createARow",
      "version": 1,
      "parameters": {
        "__IMTCONN__": 3166463
      },
      "mapper": {
        "table": "journal_entries",
        "date": "{{1.Date}}",
        "mit": "{{1.MIT}}",
        "content": "{{1.Content}}",
        "gratitude": "{{3.gratitudeArray}}",
        "notes": "{{2.notesObject}}",
        "prompt": "{{1.Prompt}}"
      },
      "metadata": {
        "designer": {
          "x": 300,
          "y": 0
        },
        "notes": "Le champ notes recevra l'objet structuré du module 2"
      }
    }
  ],
  "metadata": {
    "instant": false,
    "version": 1,
    "scenario": {
      "roundtrips": 1,
      "slots": null
    },
    "designer": {
      "orphans": []
    },
    "zone": "eu1.make.com",
    "notes": [
      {
        "content": "Ce blueprint convertit le champ \"notes\" en un objet JSONB structuré",
        "color": "#5bc0de",
        "coords": {
          "x": 0,
          "y": -200
        }
      }
    ]
  }
}

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "zinc",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

================
File: components/navigation.tsx
================
'use client';

import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';

export function Navigation() {
  const pathname = usePathname();
  
  const navItems = [
    { path: '/', label: 'Accueil' },
    { path: '/add-entry', label: 'Ajouter une entrée' },
    { path: '/generate-entry', label: 'Générer avec IA' },
    { path: '/entries', label: 'Dernières entrées' },
    { path: '/ask', label: 'Poser une question' },
  ];

  return (
    <Card className="p-4 mb-8">
      <nav className="flex flex-wrap gap-2">
        {navItems.map((item) => (
          <Button
            key={item.path}
            variant={pathname === item.path ? 'default' : 'outline'}
            asChild
          >
            <Link href={item.path}>{item.label}</Link>
          </Button>
        ))}
      </nav>
    </Card>
  );
}

================
File: components/TextWithAudio.tsx
================
'use client';

import { useState, useRef, useEffect } from 'react';
import { Textarea } from '@/components/ui/textarea';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { Mic, MicOff, Loader2 } from 'lucide-react';

interface TextWithAudioProps {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
  label?: string;
  className?: string;
  rows?: number;
  isTextarea?: boolean;
  id?: string;
}

export const TextWithAudio = ({
  value,
  onChange,
  placeholder = '',
  label,
  className = '',
  rows = 4,
  isTextarea = true,
  id,
}: TextWithAudioProps) => {
  const [isRecording, setIsRecording] = useState(false);
  const [isTranscribing, setIsTranscribing] = useState(false);
  const [isAudioSupported, setIsAudioSupported] = useState(true);
  const [error, setError] = useState('');
  const [recordingTime, setRecordingTime] = useState(0);
  const [recordingVolume, setRecordingVolume] = useState(0);
  const [countdown, setCountdown] = useState<number | null>(null);
  
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const chunksRef = useRef<Blob[]>([]);
  const recorderTimerRef = useRef<NodeJS.Timeout | null>(null);
  const audioAnalyserRef = useRef<AnalyserNode | null>(null);
  const audioContextRef = useRef<AudioContext | null>(null);
  const countdownRef = useRef<NodeJS.Timeout | null>(null);
  
  // Check if audio recording is supported
  useEffect(() => {
    const checkAudioSupport = async () => {
      try {
        if (typeof navigator === 'undefined' || 
            !navigator.mediaDevices?.getUserMedia) {
          setIsAudioSupported(false);
          return;
        }
        
        // Try to access the microphone to check permissions
        await navigator.mediaDevices.getUserMedia({ audio: true })
          .then(stream => {
            // Release the stream immediately
            stream.getTracks().forEach(track => track.stop());
          })
          .catch(() => {
            setIsAudioSupported(false);
          });
      } catch  {
        setIsAudioSupported(false);
      }
    };
    
    checkAudioSupport();
  }, []);
  
  // Fonction pour arrêter tous les processus liés à l'enregistrement
  const cleanupRecording = () => {
    // Arrêter le timer d'enregistrement
    if (recorderTimerRef.current) {
      clearInterval(recorderTimerRef.current);
      recorderTimerRef.current = null;
    }
    
    // Arrêter l'analyseur audio
    if (audioContextRef.current) {
      audioContextRef.current.close().catch(console.error);
      audioContextRef.current = null;
    }
    
    setRecordingTime(0);
    setRecordingVolume(0);
    
    // Arrêter et nettoyer le MediaRecorder
    if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {
      try {
        mediaRecorderRef.current.stop();
      } catch (e) {
        console.warn('Error stopping media recorder:', e);
      }
      
      // Libérer le microphone
      if (mediaRecorderRef.current.stream) {
        mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());
      }
    }
  };

  const startRecording = async () => {
    try {
      setError('');
      
      // Démarrer un compte à rebours de 3 secondes avant de commencer l'enregistrement
      setCountdown(3);
      
      // Nettoyer tout enregistrement précédent
      cleanupRecording();
      
      // Préparer le flux audio en avance
      const stream = await navigator.mediaDevices.getUserMedia({ 
        audio: { 
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
        } 
      });
      
      // Démarrer le compte à rebours
      let count = 3;
      countdownRef.current = setInterval(() => {
        count -= 1;
        setCountdown(count);
        
        // Quand le compte à rebours atteint 0, démarrer l'enregistrement
        if (count <= 0) {
          if (countdownRef.current) {
            clearInterval(countdownRef.current);
            countdownRef.current = null;
          }
          setCountdown(null);
          
          // Maintenant démarrer l'enregistrement avec le flux pré-acquis
          startRecordingWithStream(stream);
        }
      }, 1000);
      
    } catch (err) {
      console.error('Error starting recording:', err);
      setError('Unable to access microphone. Please check permissions.');
      setIsAudioSupported(false);
      cleanupRecording();
      setCountdown(null);
      if (countdownRef.current) {
        clearInterval(countdownRef.current);
        countdownRef.current = null;
      }
    }
  };
  
  // Fonction pour démarrer l'enregistrement avec un flux audio déjà acquis
  const startRecordingWithStream = (stream: MediaStream) => {
    try {
      chunksRef.current = [];
      
      // Configurer l'analyseur audio pour les niveaux de volume
      const audioContext = new AudioContext();
      audioContextRef.current = audioContext;
      const analyser = audioContext.createAnalyser();
      audioAnalyserRef.current = analyser;
      analyser.fftSize = 256;
      
      const source = audioContext.createMediaStreamSource(stream);
      source.connect(analyser);
      
      // Configurer le timer pour mesurer le volume et mettre à jour le temps
      const dataArray = new Uint8Array(analyser.frequencyBinCount);
      recorderTimerRef.current = setInterval(() => {
        analyser.getByteFrequencyData(dataArray);
        
        // Calculer la moyenne du volume
        const average = dataArray.reduce((sum, value) => sum + value, 0) / dataArray.length;
        setRecordingVolume(average);
        
        // Incrémenter le temps d'enregistrement (en secondes)
        setRecordingTime(prev => prev + 0.1);
      }, 100);
      
      // Set audio constraints for better quality
      const options = {
        mimeType: 'audio/webm',
      };
      
      // Try the preferred mime type, fall back to browser default if not supported
      let mediaRecorder;
      try {
        mediaRecorder = new MediaRecorder(stream, options);
      } catch  {
        console.warn('Preferred mime type not supported, using browser default');
        mediaRecorder = new MediaRecorder(stream);
      }
      
      mediaRecorderRef.current = mediaRecorder;
      
      mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) {
          chunksRef.current.push(e.data);
        }
      };
      
      mediaRecorder.onstop = async () => {
        // Add a small delay before processing to ensure all data is collected
        setTimeout(() => {
          const audioBlob = new Blob(chunksRef.current, { 
            type: 'audio/webm' 
          });
          processAudioToText(audioBlob);
        }, 500);
      };
      
      // Request data more frequently (every 200ms)
      mediaRecorder.start(200);
      setIsRecording(true);
    } catch (err) {
      console.error('Error during recording setup:', err);
      setError('Error setting up recording. Please try again.');
      cleanupRecording();
    }
  };
  
  const stopRecording = () => {
    // Arrêter le compte à rebours si actif
    if (countdownRef.current) {
      clearInterval(countdownRef.current);
      countdownRef.current = null;
      setCountdown(null);
    }
    
    if (mediaRecorderRef.current && isRecording) {
      // Mark as not recording immediately to update UI
      setIsRecording(false);
      
      // Add a small delay before stopping to ensure we capture the full phrase
      setTimeout(() => {
        if (mediaRecorderRef.current) {
          mediaRecorderRef.current.stop();
          
          // Stop all tracks to release the microphone
          if (mediaRecorderRef.current.stream) {
            mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());
          }
          
          // Clean up recording resources
          cleanupRecording();
        }
      }, 1000); // Increased delay for better capture of the end of phrases
    }
  };
  
  const processAudioToText = async (audioBlob: Blob) => {
    try {
      setIsTranscribing(true);
      setError('');
      
      // Create FormData with the audio blob
      const formData = new FormData();
      // Explicitly set the filename with .webm extension to ensure proper MIME type detection
      formData.append('audio', audioBlob, 'recording.webm');
      
      // Send to our transcription API
      const response = await fetch('/api/transcribe', {
        method: 'POST',
        body: formData,
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.details || `API Error: ${response.status}`);
      }
      
      const data = await response.json();
      
      // Update the text with transcribed content
      // Append to existing content if there is any
      if (value && value.trim() !== '') {
        onChange(`${value} ${data.text}`);
      } else {
        onChange(data.text);
      }
    } catch (err) {
      console.error('Error during transcription:', err);
      setError(err instanceof Error ? err.message : 'Unable to transcribe audio. Please enter your text manually.');
    } finally {
      setIsTranscribing(false);
    }
  };
  
  // Nettoyer les ressources lors du démontage du composant
  useEffect(() => {
    return () => {
      cleanupRecording();
    };
  }, []);
  
  const TextComponent = isTextarea ? Textarea : Input;
  
  return (
    <div className="relative">
      {label && (
        <label htmlFor={id} className="text-sm font-medium block mb-2">
          {label}
        </label>
      )}
      
      <div className="relative">
        <TextComponent
          id={id}
          value={value}
          onChange={(e) => onChange(e.target.value)}
          placeholder={placeholder}
          rows={isTextarea ? rows : undefined}
          className={`${className} ${isTextarea ? 'resize-none' : ''} pr-12`}
          disabled={isTranscribing || countdown !== null}
        />
        
        {isAudioSupported && (
          <div className="absolute right-2 top-1/2 -translate-y-1/2 flex items-center">
            {countdown !== null && (
              <div className="mr-2 text-sm font-medium bg-blue-100 text-blue-800 px-2 py-1 rounded-full">
                {countdown}
              </div>
            )}
            {isRecording && (
              <div 
                className="mr-2 h-2 w-2 rounded-full bg-red-500 animate-pulse"
                style={{
                  transform: `scale(${1 + (recordingVolume / 255) * 1.5})`,
                  opacity: 0.7 + (recordingVolume / 255) * 0.3
                }}
              />
            )}
            {isRecording && (
              <div className="mr-2 text-xs text-gray-500">
                {recordingTime.toFixed(1)}s
              </div>
            )}
            <Button
              type="button"
              variant="ghost"
              size="icon"
              className={`h-8 w-8 rounded-full ${
                isRecording ? 'bg-red-100 text-red-500 hover:bg-red-200 hover:text-red-600' : 
                countdown !== null ? 'bg-blue-100 text-blue-500' : ''
              }`}
              onClick={isRecording || countdown !== null ? stopRecording : startRecording}
              disabled={isTranscribing}
              title={
                isRecording ? 'Stop recording' : 
                countdown !== null ? 'Cancel countdown' : 
                'Start recording'
              }
            >
              {isRecording ? (
                <MicOff className="h-4 w-4" />
              ) : isTranscribing ? (
                <Loader2 className="h-4 w-4 animate-spin" />
              ) : (
                <Mic className="h-4 w-4" />
              )}
            </Button>
          </div>
        )}
      </div>
      
      {error && (
        <p className="text-sm text-red-500 mt-1">{error}</p>
      )}
      
      {(isRecording || countdown !== null) && (
        <div className={`absolute top-0 left-0 w-full h-full border-2 pointer-events-none rounded-md ${
          isRecording ? 'border-red-500' : 'border-blue-500'
        }`} />
      )}
    </div>
  );
};

================
File: components/ui/alert-dialog.tsx
================
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}

================
File: components/ui/button.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }

================
File: components/ui/card.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}

================
File: components/ui/form.tsx
================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  useFormState,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState } = useFormContext()
  const formState = useFormState({ name: fieldContext.name })
  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

function FormItem({ className, ...props }: React.ComponentProps<"div">) {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div
        data-slot="form-item"
        className={cn("grid gap-2", className)}
        {...props}
      />
    </FormItemContext.Provider>
  )
}

function FormLabel({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  const { error, formItemId } = useFormField()

  return (
    <Label
      data-slot="form-label"
      data-error={!!error}
      className={cn("data-[error=true]:text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
}

function FormControl({ ...props }: React.ComponentProps<typeof Slot>) {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      data-slot="form-control"
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
}

function FormDescription({ className, ...props }: React.ComponentProps<"p">) {
  const { formDescriptionId } = useFormField()

  return (
    <p
      data-slot="form-description"
      id={formDescriptionId}
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function FormMessage({ className, ...props }: React.ComponentProps<"p">) {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : props.children

  if (!body) {
    return null
  }

  return (
    <p
      data-slot="form-message"
      id={formMessageId}
      className={cn("text-destructive text-sm", className)}
      {...props}
    >
      {body}
    </p>
  )
}

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}

================
File: components/ui/input.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }

================
File: components/ui/label.tsx
================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }

================
File: components/ui/textarea.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }

================
File: DOC_JOURNAL.md
================
Analyze l'entrée suivante : 

Ca doit être une entrée de journal, avec mon prompt user et la réponse de chat GPT avec une strucure resemblant ça :
- MIT : Most Important Task of the day 
- Content : Le résumé de ma journéem, 3 choses que je suis reconnaissants aujourd'hui et mes évaluations personnelles selon ma productivité, mon sport, mon énergie,la propreté et mon art
- La date ! C'est par défaut 2024 si tu ne trouves pas la date

J'ai donc besoin de 4 paramètres :-
- MIT, le contentenu, la date et le prompt

================
File: eslint.config.mjs
================
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
  {
    rules: {
      "@typescript-eslint/no-explicit-any": "off",
    },
  },
];

export default eslintConfig;

================
File: lib/utils.ts
================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: migrate-gratitude-jsonb.sql
================
-- Étape 1: Renommer l'ancienne colonne gratitude en gratitude_old
ALTER TABLE journal_entries RENAME COLUMN gratitude TO gratitude_old;

-- Étape 2: Créer une nouvelle colonne de type jsonb
ALTER TABLE journal_entries ADD COLUMN gratitude jsonb DEFAULT '[]'::jsonb;

-- Note: Une fois que l'application a été mise à jour pour utiliser la nouvelle colonne,
-- vous pourrez supprimer l'ancienne colonne si nécessaire avec:
-- ALTER TABLE journal_entries DROP COLUMN gratitude_old;

================
File: next.config.js
================
/** @type {import('next').NextConfig} */
const nextConfig = {
  env: {
    NOTION_KEY: process.env.NOTION_KEY,
  },
};

module.exports = nextConfig;

================
File: next.config.ts
================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;

================
File: package.json
================
{
  "name": "journal-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@hookform/resolvers": "^4.1.3",
    "@notionhq/client": "^2.3.0",
    "@radix-ui/react-alert-dialog": "^1.1.6",
    "@radix-ui/react-icons": "^1.3.2",
    "@radix-ui/react-label": "^2.1.2",
    "@radix-ui/react-slot": "^1.1.2",
    "@supabase/supabase-js": "^2.49.4",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.485.0",
    "next": "15.2.4",
    "notion-to-md": "^4.0.0-alpha.4",
    "openai": "^4.28.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-hook-form": "^7.55.0",
    "react-markdown": "^10.1.0",
    "shadcn-ui": "^0.9.5",
    "tailwind-merge": "^3.0.2",
    "tw-animate-css": "^1.2.5",
    "zod": "^3.24.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "autoprefixer": "^10.4.21",
    "eslint": "^9",
    "eslint-config-next": "15.2.4",
    "postcss": "^8.5.3",
    "tailwindcss": "^4.0.17",
    "typescript": "^5"
  }
}

================
File: postcss.config.mjs
================
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;

================
File: public/file.svg
================
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>

================
File: public/globe.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>

================
File: public/next.svg
================
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>

================
File: public/vercel.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>

================
File: public/window.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>

================
File: README.md
================
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

# Journal App - Application de journal personnel avec IA

Une application moderne de journal personnel qui utilise l'intelligence artificielle pour la génération d'entrées structurées, la recherche sémantique et l'analyse de texte.

## Objectif du projet

Cette application vise à simplifier la tenue d'un journal personnel en:

1. **Générant automatiquement des entrées structurées** à partir de descriptions simples ou d'enregistrements audio
2. **Permettant des recherches intelligentes** à travers toutes les entrées passées
3. **Offrant une analyse IA** basée sur l'historique complet de votre journal

## Architecture technique

### Stack technologique

- **Frontend**: Next.js 15+ (App Router), React, TypeScript, Tailwind CSS, shadcn/ui
- **Backend**: API Routes Next.js
- **Base de données**: PostgreSQL (avec vectorisation pour la recherche sémantique)
- **IA**: 
  - OpenAI: ChatGPT pour la génération d'entrées structurées
  - OpenAI: Whisper pour la transcription audio
  - OpenAI: Embeddings pour la recherche vectorielle

### Structure du projet

```
journal-app/
├── app/                    # App Router de Next.js
│   ├── api/                # Routes API
│   │   ├── add-entry/      # Ajouter une entrée
│   │   ├── generate-entry/ # Générer une entrée avec IA
│   │   ├── search/         # Recherche d'entrées
│   │   └── transcribe/     # Transcription audio
│   ├── generate-entry/     # Page de génération d'entrées
│   └── ...                 # Autres pages
├── components/             # Composants React réutilisables
│   ├── TextWithAudio.tsx   # Composant d'entrée texte avec enregistrement audio
│   └── ...                 # Autres composants
└── types/                  # Définitions TypeScript
```

### Modèle de données

```typescript
interface JournalEntry {
  id?: string;
  date: string;
  mit: string;         // Most Important Task
  content: string;     # Contenu principal de l'entrée
  gratitude?: any;     # Points de gratitude
  notes?: {            # Évaluations numériques
    productivite?: number;
    sport?: number;
    energie?: number;
    proprete?: number;
    art?: number;
  };
  embedding?: number[]; # Vecteur pour la recherche sémantique
}
```

## Fonctionnalités clés

### 1. Génération d'entrées assistée par IA

L'application convertit une description simple ou un enregistrement audio en une entrée de journal structurée, incluant:
- Tâche principale de la journée
- Contenu principal
- Points de gratitude
- Évaluations numériques (énergie, productivité, etc.)

### 2. Transcription audio

Utilise OpenAI Whisper pour transcrire les enregistrements audio en texte:
- Modèle actuel: `whisper-1`
- Détection automatique de la langue
- Intégration directe dans les champs de texte

### 3. Recherche sémantique

Permet de poser des questions en langage naturel et de retrouver les entrées pertinentes grâce aux embeddings vectoriels.

## Guide d'amélioration de la reconnaissance vocale

Pour obtenir une meilleure qualité de transcription:

1. **Utilisez un microphone de qualité** si possible
2. **Parlez clairement et à un rythme modéré**
3. **Attendez la fin du compte à rebours** avant de commencer à parler
4. **Évitez les environnements bruyants**
5. **Alternatives techniques possibles**:
   - Utiliser le modèle `gpt-4o-mini-transcribe` ou `gpt-4o-transcribe` pour une meilleure précision (nécessite une mise à jour de la clé API)
   - Implémenter une solution locale comme Mozilla DeepSpeech pour plus de confidentialité
   - Utiliser un service spécialisé comme Google Speech-to-Text ou Azure Speech Services

### Fonctionnalités de l'enregistrement audio

Le composant `TextWithAudio` inclut les fonctionnalités suivantes:

- **Compte à rebours** - Délai de 3 secondes avant le début de l'enregistrement
- **Visualisation du volume** - Indicateur visuel qui change selon le volume de votre voix
- **Compteur de temps** - Affiche la durée de l'enregistrement en secondes
- **Optimisations audio** - Suppression de bruit, annulation d'écho et contrôle automatique du gain
- **Indicateurs visuels** - Bordure colorée, icône animée et retour visuel durant l'enregistrement

## Configuration du développement

### ESLint

Le projet utilise ESLint pour le linting du code. Si vous rencontrez des erreurs de linting que vous souhaitez désactiver, vous pouvez les configurer dans le fichier `.eslintrc.json` à la racine du projet:

```json
{
  "extends": [
    "next/core-web-vitals"
  ],
  "rules": {
    "@typescript-eslint/no-unused-vars": "off"
    // Ajoutez ici d'autres règles à désactiver si nécessaire
  }
}
```

### TypeScript

Pour éviter les erreurs courantes de type comme les tableaux vides, assurez-vous de toujours typer explicitement vos variables, par exemple:

```typescript
// À éviter
const items = [];

// Préférer
const items: SomeType[] = [];
```

## Démarrage

```bash
# Installation des dépendances
npm install

# Lancement du serveur de développement
npm run dev

# Construction pour production
npm run build

# Lancement en production
npm start
```

Vous devez également configurer un fichier `.env.local` avec:

```
OPENAI_API_KEY=votre_clé_api_openai
DATABASE_URL=votre_url_de_base_de_données
```

## Roadmap

- [ ] Amélioration de la qualité de transcription audio
- [ ] Exportation des entrées en différents formats
- [ ] Visualisations et analyses de tendances
- [ ] Application mobile

================
File: split-journal.js
================
// split-journal.js
const fs = require('fs');
const path = require('path');

// Configuration
const sourceDir = path.join(__dirname, 'data_journal', 'source_chatgpt');
const outputDir = path.join(__dirname, 'data_journal', 'entries');
const entrySeparator = /^ChatGPT a dit :/m;

// Nettoyer le répertoire de sortie
if (fs.existsSync(outputDir)) {
  fs.rmSync(outputDir, { recursive: true });
}
fs.mkdirSync(outputDir, { recursive: true });

// Traiter tous les fichiers
fs.readdirSync(sourceDir).forEach(file => {
  const content = fs.readFileSync(path.join(sourceDir, file), 'utf8');
  
  // Découper en entrées ChatGPT
  const entries = content.split(entrySeparator)
    .slice(1) // Ignorer le contenu avant le premier séparateur
    .map(entry => entry.replace(/Vous avez dit :.*?($|\nChatGPT)/gs, '').trim());

  // Sauvegarder chaque entrée
  entries.forEach((entry, index) => {
    if (!entry) return;
    
    const filename = `entry_${path.basename(file, '.txt')}_${String(index + 1).padStart(3, '0')}.md`;
    fs.writeFileSync(path.join(outputDir, filename), entry);
  });
});

console.log('Traitement terminé ! Entrées ChatGPT extraites avec succès.');

================
File: supabase-pgvector.sql
================
-- Activer l'extension pgvector
CREATE EXTENSION IF NOT EXISTS vector;

-- S'assurer que la colonne embedding existe dans la table journal_entries
ALTER TABLE journal_entries ADD COLUMN IF NOT EXISTS embedding vector(1536);

-- Créer un index pour accélérer les recherches
CREATE INDEX IF NOT EXISTS journal_entries_embedding_idx 
ON journal_entries 
USING ivfflat (embedding vector_l2_ops) 
WITH (lists = 1000);

-- Supprimer la fonction existante avant de la recréer
DROP FUNCTION IF EXISTS match_entries(vector(1536), float, integer);

-- Fonction RPC pour chercher les entrées similaires
CREATE OR REPLACE FUNCTION match_entries(
  query_embedding vector(1536),
  match_threshold float DEFAULT 0.3,
  match_count int DEFAULT 1000
)
RETURNS TABLE (
  id uuid,
  date text,
  mit text,
  content text,
  prompt text,
  gratitude text[],
  notes jsonb,
  similarity float
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    journal_entries.id,
    journal_entries.date::text,
    journal_entries.mit,
    journal_entries.content,
    journal_entries.prompt,
    journal_entries.gratitude,
    journal_entries.notes,
    1 - (journal_entries.embedding <=> query_embedding) AS similarity
  FROM journal_entries
  WHERE journal_entries.embedding IS NOT NULL
  ORDER BY journal_entries.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

================
File: supabase/migrations/journal_schema.sql
================
-- Enable the pgvector extension if it's not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create the journal_entries table if it doesn't exist
CREATE TABLE IF NOT EXISTS journal_entries (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  date DATE NOT NULL,
  mit TEXT NOT NULL,
  content TEXT NOT NULL,
  gratitude TEXT[] NOT NULL,
  notes JSONB NOT NULL,
  embedding VECTOR(1536),
  created_at TIMESTAMPTZ DEFAULT now()
);

-- Create the vector similarity search function
CREATE OR REPLACE FUNCTION match_journal_entries(query_embedding VECTOR(1536), match_threshold FLOAT, match_count INT)
RETURNS TABLE (
  id UUID,
  date DATE,
  mit TEXT,
  content TEXT,
  gratitude TEXT[],
  notes JSONB,
  similarity FLOAT
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    journal_entries.id,
    journal_entries.date,
    journal_entries.mit,
    journal_entries.content,
    journal_entries.gratitude,
    journal_entries.notes,
    1 - (journal_entries.embedding <=> query_embedding) AS similarity
  FROM journal_entries
  WHERE 1 - (journal_entries.embedding <=> query_embedding) > match_threshold
  ORDER BY journal_entries.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

-- Create the vector cosine index for better search performance
CREATE INDEX IF NOT EXISTS journal_entries_embedding_idx 
ON journal_entries 
USING ivfflat (embedding vector_cosine_ops) 
WITH (lists = 100);

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    },
    "noImplicitAny": false
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
